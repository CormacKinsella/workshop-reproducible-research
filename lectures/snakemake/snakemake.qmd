---
title: "Snakemake workflow manager"
subtitle: "NBIS/ELIXIR-SE Tools for Reproducible Research"
#author: "National Bioinformatics Infrastructure Sweden"
number-sections: false
format:
    html:
        output-file: "snakemake.html"
        css: "template.css"
        toc: true
    revealjs:
        output-file: "snakemake-revealjs.html"
        footer: "NBIS Reproducible research - Snakemake"
        css: "template.css"
        theme: default
        smaller: true
        code-block-border-left: true
        code-block-background: true
        
    #pdf:
     #   output-file: "snakemake.pdf"
format-links: false
highlight-style: a11y
---

# Making reproducible workflows with
<img src="https://snakemake.github.io/img/jk/logo.png" style="background-color:#002221;width:10%;padding: 15px 15px 15px 15px;">

# Why do we need workflow managers?

![](https://images.unsplash.com/photo-1549319114-d67887c51aed?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1867&q=80)

As projects grow or age, it becomes increasingly difficult to keep track of all the parts and how they fit together.

# Workflow managers

**Most common**

- [Snakemake]{.green}
- [Nextflow]{.green}

**Others**

- Makeflow
- Bpipe
- Pachyderm

# Snakemake workflows

::: {.incremental}
- automatically track input/output file dependencies
- are built from [rules]{.green}
- are generalized with [wildcards]{.green}
- use a [Python-based]{.green} definition language
- easily scale from laptops to HPC clusters
:::

# Reproducible...

![](repr_scal_1.png)

# ...and scalable workflows

![](repr_scal_2.png)

# Example: sequence trimming

**Goal**: Create workflow to trim and compress fastq-files

```{.default code-line-numbers=false}
./
 ├── a.fastq
 └── b.fastq
```
# Example: sequence trimming

Using a bash-script:

```{.bash code-line-numbers="|1-2,10|3|4-5|6-7|8-9"}
for input in *.fastq
do  
   sample=$(echo ${input} | sed 's/.fastq//')  
   # 1. Trim fastq file (trim 5 bp from left, 10 bp from right)
   seqtk trimfq -b 5 -e 10 $input > ${sample}.trimmed.fastq
   # 2. Compress fastq file
   gzip -c ${sample}.trimmed.fastq > ${sample}.trimmed.fastq.gz
   # 3. Remove intermediate files  
   rm ${sample}.trimmed.fastq
done
```

::: {.fragment}

```{.default code-line-numbers=false}
$ bash trimfastq.sh
```
:::

# Example: sequence trimming

Using snakemake rules:

```{.python code-line-numbers="|1,6|3|2,8|4,5,9,10|7"}
rule trim_fastq:
    output: temp("{sample}.trimmed.fastq")
    input: "{sample}.fastq"
    shell:
        "seqtk trimfq -b 5 -e 10 {input} > {output}"
rule gzip:
    output: "{sample}.trimmed.fastq.gz"
    input: "{sample}.trimmed.fastq"
    shell:
        "gzip -c {input} > {output}"
```

::: {.fragment}
``` {.default code-line-numbers=false}
$ snakemake -c 1 {a,b}.trimmed.fastq.gz
```
:::

---

## {auto-animate=true}

``` {.default code-line-numbers=false}
$ snakemake -c 1 {a,b}.trimmed.fastq.gz
```

## {auto-animate=true}

``` {.default code-line-numbers=false}
$ snakemake -c 1 {a,b}.trimmed.fastq.gz
Provided cores: 1
Rules claiming more threads will be scaled down.
Job counts:
count   jobs
2       gzip
2       trim_fastq
4        
```

## {auto-animate=true}

``` {.default code-line-numbers=false}
$ snakemake -c 1 {a,b}.trimmed.fastq.gz
Provided cores: 1
Rules claiming more threads will be scaled down.
Job counts:
count   jobs
2       gzip
2       trim_fastq
4       
rule trim_fastq:
    input: a.fastq
    output: a.trimmed.fastq
    wildcards: sample=a
    1 of 4 steps (25%) done
    
rule gzip:
    input: a.trimmed.fastq
    output: a.trimmed.fastq.gz
    wildcards: sample=a
Removing temporary output file a.trimmed.fastq.
2 of 4 steps (50%) done
```

## {auto-animate=true}

``` {.default code-line-numbers=false}
$ snakemake -c 1 {a,b}.trimmed.fastq.gz
Provided cores: 1
Rules claiming more threads will be scaled down.
Job counts:
count   jobs
2       gzip
2       trim_fastq
4       
rule trim_fastq:
    input: a.fastq
    output: a.trimmed.fastq
    wildcards: sample=a
    1 of 4 steps (25%) done

rule gzip:
    input: a.trimmed.fastq
    output: a.trimmed.fastq.gz
    wildcards: sample=a
Removing temporary output file a.trimmed.fastq.
2 of 4 steps (50%) done

rule trim_fastq:
    input: b.fastq
    output: b.trimmed.fastq
    wildcards: sample=b
3 of 4 steps (75%) done

rule gzip:
    input: b.trimmed.fastq
    output: b.trimmed.fastq.gz
    wildcards: sample=b
Removing temporary output file b.trimmed.fastq.
4 of 4 steps (100%) done
```

# Getting into the Snakemake mindset

From the [Snakemake documentation](https://snakemake.readthedocs.io/en/stable/tutorial/basics.html#basics-an-example-workflow):

::: {.incremental}

- "A Snakemake workflow is defined by specifying rules in a Snakefile."
- "Rules decompose the workflow into small steps."
- "Snakemake automatically determines the dependencies between the rules by matching file names."

:::


## {auto-animate=true}

- By themselves, rules only define what files [can]{.green} be generated

```{dot}
digraph snakemake_dag {
    graph[bgcolor=white, margin=0];
    node[shape=box, style=rounded, fontname=sans,                 fontsize=10, penwidth=2];
    edge[penwidth=2, color=grey];
0 [ shape=none, margin=0, label=<<table border="2" color="#57D957" cellspacing="3" cellborder="0">
<tr><td>
<b><font point-size="18">               gzip              </font></b>
</td></tr>
<hr/>
<tr><td align="left"> <b><font point-size="14">&#8618; input</font></b> </td></tr>
<tr>
<td align="left"><font face="monospace">{sample}.trimmed.fastq</font></td>
</tr>
<hr/>
<tr><td align="right"> <b><font point-size="14">output &rarr;</font></b> </td> </tr>
<tr>
<td align="left"><font face="monospace">{sample}.trimmed.fastq.gz</font></td></tr>
</table>>]
1 [ shape=none, margin=0, label=<<table border="2" color="#D95757" cellspacing="3" cellborder="0">
<tr><td>
<b><font point-size="18">       trim_fastq       </font></b>
</td></tr>
<hr/>
<tr><td align="left"> <b><font point-size="14">&#8618; input</font></b> </td></tr>
<tr>
<td align="left"><font face="monospace">{sample}.fastq</font></td>
</tr>
<hr/>
<tr><td align="right"> <b><font point-size="14">output &rarr;</font></b> </td> </tr>
<tr>
<td align="left"><font face="monospace">{sample}.trimmed.fastq</font></td></tr>
</table>>]
        1 -> 0
}
```

## {auto-animate=true}

- By themselves, rules only define what files [can]{.green} be generated
- The actual rules to run are determined automatically from the files you [want]{.green}, so called [targets]{.green}


``` {.default code-line-numbers=false}
$ snakemake -c 1 {a,b}.trimmed.fastq.gz
```

```{dot}
digraph snakemake_dag {
    graph[bgcolor=white, margin=0];
    node[shape=box, style=rounded, fontname=sans, fontsize=10, penwidth=2];
    edge[penwidth=2, color=grey];
    
0 [ shape=none, margin=0, label=<<table border="2" color="#57D957" cellspacing="3" cellborder="0">
<tr><td>
<b><font point-size="18">        gzip       </font></b>
</td></tr>
<hr/>
<tr><td align="left"> <b><font point-size="14">&#8618; input</font></b> </td></tr>
<tr>
<td align="left"><font point-size="8" face="monospace">a.trimmed.fastq</font></td>
</tr>
<hr/>
<tr><td align="right"> <b><font point-size="14">output &rarr;</font></b> </td> </tr>
<tr>
<td align="left"><font point-size="8" face="monospace">a.trimmed.fastq.gz</font></td></tr>
</table>>]

1 [ shape=none, margin=0, label=<<table border="2" color="#D95757" cellspacing="3" cellborder="0">
<tr><td>
<b><font point-size="18">trim_fastq</font></b>
</td></tr>
<hr/>
<tr><td align="left"> <b><font point-size="10">&#8618; input</font></b> </td></tr>
<tr>
<td align="left"><font point-size="8" face="monospace">a.fastq</font></td>
</tr>
<hr/>
<tr><td align="right"> <b><font point-size="14">output &rarr;</font></b> </td> </tr>
<tr>
<td align="left"><font point-size="8" face="monospace">a.trimmed.fastq</font></td></tr>
</table>>]


2 [ shape=none, margin=0, label=<<table border="2" color="#57D957" cellspacing="3" cellborder="0">
<tr><td>
<b><font point-size="18">        gzip       </font></b>
</td></tr>
<hr/>
<tr><td align="left"> <b><font point-size="14">&#8618; input</font></b> </td></tr>
<tr>
<td align="left"><font point-size="8" face="monospace">b.trimmed.fastq</font></td>
</tr>
<hr/>
<tr><td align="right"> <b><font point-size="14">output &rarr;</font></b> </td> </tr>
<tr>
<td align="left"><font point-size="8" face="monospace">b.trimmed.fastq.gz</font></td></tr>
</table>>]

3 [ shape=none, margin=0, label=<<table border="2" color="#D95757" cellspacing="3" cellborder="0">
<tr><td>
<b><font point-size="18">trim_fastq</font></b>
</td></tr>
<hr/>
<tr><td align="left"> <b><font point-size="10">&#8618; input</font></b> </td></tr>
<tr>
<td align="left"><font point-size="8" face="monospace">b.fastq</font></td>
</tr>
<hr/>
<tr><td align="right"> <b><font point-size="14">output &rarr;</font></b> </td> </tr>
<tr>
<td align="left"><font point-size="8" face="monospace">b.trimmed.fastq</font></td></tr>
</table>>]

        1 -> 0
        3 -> 2
}
```

## {auto-animate=true}

- By themselves, rules only define what files [can]{.green} be generated
- The actual rules to run are determined automatically from the files you [want]{.green}, so called [targets]{.green}


``` {.default code-line-numbers=false}
$ snakemake -c 1 a.trimmed.fastq.gz
```

```{dot}
digraph snakemake_dag {
    graph[bgcolor=white, margin=0];
    node[shape=box, style=rounded, fontname=sans, fontsize=10, penwidth=2];
    edge[penwidth=2, color=grey];
    
0 [ shape=none, margin=0, label=<<table border="2" color="#57D957" cellspacing="3" cellborder="0">
<tr><td>
<b><font point-size="18">        gzip       </font></b>
</td></tr>
<hr/>
<tr><td align="left"> <b><font point-size="14">&#8618; input</font></b> </td></tr>
<tr>
<td align="left"><font point-size="8" face="monospace">a.trimmed.fastq</font></td>
</tr>
<hr/>
<tr><td align="right"> <b><font point-size="14">output &rarr;</font></b> </td> </tr>
<tr>
<td align="left"><font point-size="8" face="monospace">a.trimmed.fastq.gz</font></td></tr>
</table>>]

1 [ shape=none, margin=0, label=<<table border="2" color="#D95757" cellspacing="3" cellborder="0">
<tr><td>
<b><font point-size="18">trim_fastq</font></b>
</td></tr>
<hr/>
<tr><td align="left"> <b><font point-size="10">&#8618; input</font></b> </td></tr>
<tr>
<td align="left"><font point-size="8" face="monospace">a.fastq</font></td>
</tr>
<hr/>
<tr><td align="right"> <b><font point-size="14">output &rarr;</font></b> </td> </tr>
<tr>
<td align="left"><font point-size="8" face="monospace">a.trimmed.fastq</font></td></tr>
</table>>]

        1 -> 0
}
```

## {auto-animate=true}

- By themselves, rules only define what files [can]{.green} be generated
- The actual rules to run are determined automatically from the files you [want]{.green}, so called [targets]{.green}
- It can therefore be helpful to think of Snakemake workflows in a bottom-up manner, [starting with the output]{.green}

:::: {.columns}

::: {.column width="45%"}
``` {.python code-line-numbers="2,7"}
rule trim_fastq:
    output: temp("{sample}.trimmed.fastq")
    input: "{sample}.fastq"
    shell:
        "seqtk trimfq -b 5 -e 10 {input} > {output}"
rule gzip:
    output: "{sample}.trimmed.fastq.gz"
    input: "{sample}.trimmed.fastq"
    shell:
        "gzip -c {input} > {output}"
```
:::

::: {.column width="55%"}
``` {dot}
digraph snakemake_dag {
    graph[bgcolor=white, margin=2];
    node[shape=box, style=rounded, fontname=sans, fontsize=10, penwidth=2];
    edge[penwidth=2, color=grey];
0 [ shape=none, margin=0, label=<<table border="2" color="#57D957" cellspacing="3" cellborder="0">
<tr><td>
<b><font point-size="18">               gzip              </font></b>
</td></tr>
<hr/>
<tr><td align="left"> <b><font point-size="14">&#8618; input</font></b> </td></tr>
<tr>
<td align="left"><font face="monospace">{sample}.trimmed.fastq</font></td>
</tr>
<hr/>
<tr><td align="right"> <b><font point-size="14">output &rarr;</font></b> </td> </tr>
<tr>
<td align="left"><font face="monospace">{sample}.trimmed.fastq.gz</font></td></tr>
</table>>]
1 [ shape=none, margin=0, label=<<table border="2" color="#D95757" cellspacing="3" cellborder="0">
<tr><td>
<b><font point-size="18">       trim_fastq       </font></b>
</td></tr>
<hr/>
<tr><td align="left"> <b><font point-size="14">&#8618; input</font></b> </td></tr>
<tr>
<td align="left"><font face="monospace">{sample}.fastq</font></td>
</tr>
<hr/>
<tr><td align="right"> <b><font point-size="14">output &rarr;</font></b> </td> </tr>
<tr>
<td align="left"><font face="monospace">{sample}.trimmed.fastq</font></td></tr>
</table>>]
        1 -> 0
}
```
:::

::::

## {auto-animate=true}

- By themselves, rules only define what files [can]{.green} be generated
- The actual rules to run are determined automatically from the files you [want]{.green}, so called [targets]{.green}
- It can therefore be helpful to think of Snakemake workflows in a bottom-up manner, [starting with the output]{.green}
- If no target is passed at the command line, Snakemake will use the first defined rule in the Snakefile as a target

``` {.python code-line-numbers="1-4"}
rule all:
    input:
        "a.trimmed.fastq.gz",
        "b.trimmed.fastq.gz"
rule trim_fastq:
    output: temp("{sample}.trimmed.fastq")
    input: "{sample}.fastq"
    shell:
        "seqtk trimfq -b 5 -e 10 {input} > {output}"
rule gzip:
    output: "{sample}.trimmed.fastq.gz"
    input: "{sample}.trimmed.fastq"
    shell:
        "gzip -c {input} > {output}"
```

# How does Snakemake keep track of what files to generate?
*Example from the practical tutorial*

## {auto-animate=true transition="none"}

- The tutorial contains a workflow to download and map RNA-seq reads against a reference genome.


``` {dot}
digraph snakemake_dag {
    graph[bgcolor=white, margin=1];
    node[shape=box, style=rounded, fontname=sans,                 fontsize=10, penwidth=2];
    edge[penwidth=2, color=grey];
        0[label = "make_supplementary", color = "0.50 0.6 0.85", style="rounded"];
        1[label = "generate_count_table", color = "0.33 0.6 0.85", style="rounded"];
        2[label = "sort_bam\nprefix: intermediate/SRR935090", color = "0.00 0.6 0.85", style="rounded"];
        3[label = "align_to_genome", color = "0.22 0.6 0.85", style="rounded"];
        4[label = "get_SRA_by_accession\nsample_id: SRR935090", color = "0.11 0.6 0.85", style="rounded"];
        5[label = "index_genome", color = "0.06 0.6 0.85", style="rounded"];
        6[label = "get_genome_fasta\ngenome_id: NCTC8325", color = "0.56 0.6 0.85", style="rounded"];
        7[label = "get_genome_gff3\ngenome_id: NCTC8325", color = "0.44 0.6 0.85", style="rounded"];
        8[label = "multiqc", color = "0.28 0.6 0.85", style="rounded"];
        9[label = "fastqc", color = "0.17 0.6 0.85", style="rounded"];
        10[label = "generate_rulegraph", color = "0.39 0.6 0.85", style="rounded"];
        1 -> 0
        8 -> 0
        10 -> 0
        2 -> 1
        7 -> 1
        3 -> 2
        4 -> 3
        5 -> 3
        6 -> 5
        9 -> 8
        4 -> 9
} 
```

## {auto-animate=true transition="none"}

- The tutorial contains a workflow to download and map RNA-seq reads against a reference genome.
- Here we ask for [results/supplementary.html]{.green}, which is an R Markdown report generated by the rule `make_supplementary`:

``` {.default code-line-numbers=false}
$ snakemake -c 1 results/supplementary.html
```

``` {dot}
digraph snakemake_dag {
    graph[bgcolor=white, margin=1];
    node[shape=box, style=rounded, fontname=sans,                 fontsize=10, penwidth=2];
    edge[penwidth=2, color=grey];
        0[label = "make_supplementary", color = "0.50 0.6 0.85", style="rounded"];
        1[label = "generate_count_table", color = "0.33 0.6 0.85", style="rounded"];
        2[label = "sort_bam\nprefix: intermediate/SRR935090", color = "0.00 0.6 0.85", style="rounded"];
        3[label = "align_to_genome", color = "0.22 0.6 0.85", style="rounded"];
        4[label = "get_SRA_by_accession\nsample_id: SRR935090", color = "0.11 0.6 0.85", style="rounded"];
        5[label = "index_genome", color = "0.06 0.6 0.85", style="rounded"];
        6[label = "get_genome_fasta\ngenome_id: NCTC8325", color = "0.56 0.6 0.85", style="rounded"];
        7[label = "get_genome_gff3\ngenome_id: NCTC8325", color = "0.44 0.6 0.85", style="rounded"];
        8[label = "multiqc", color = "0.28 0.6 0.85", style="rounded"];
        9[label = "fastqc", color = "0.17 0.6 0.85", style="rounded"];
        10[label = "generate_rulegraph", color = "0.39 0.6 0.85", style="rounded"];
        1 -> 0
        8 -> 0
        10 -> 0
        2 -> 1
        7 -> 1
        3 -> 2
        4 -> 3
        5 -> 3
        6 -> 5
        9 -> 8
        4 -> 9
} 
```

## {auto-animate=true transition="none"}

- The tutorial contains a workflow to download and map RNA-seq reads against a reference genome.
- Here we ask for [results/supplementary.html]{.green}, which is an R Markdown report generated by the rule `make_supplementary`:
- If the timestamp of a file upstream in the workflow is updated, Snakemake detects a filechange and reruns the necessary rules.

``` {.default code-line-numbers=false}
$ touch intermediate/NCTC8325.1.bt2 
$ snakemake -c 1 results/supplementary.html
```

``` {dot}
digraph snakemake_dag {
    graph[bgcolor=white, margin=1];
    node[shape=box, style=rounded, fontname=sans,                 fontsize=10, penwidth=2];
    edge[penwidth=2, color=grey];
        0[label = "make_supplementary", color = "0.22 0.6 0.85", style="rounded"];
        1[label = "generate_count_table", color = "0.11 0.6 0.85", style="rounded"];
        2[label = "sort_bam\nprefix: intermediate/SRR935090", color = "0.61 0.6 0.85", style="rounded"];
        3[label = "align_to_genome", color = "0.56 0.6 0.85", style="rounded"];
        4[label = "get_SRA_by_accession\nsample_id: SRR935090", color = "0.44 0.6 0.85", style="rounded,dashed"];
        5[label = "index_genome", color = "0.00 0.6 0.85", style="rounded,dashed"];
        6[label = "get_genome_fasta\ngenome_id: NCTC8325", color = "0.33 0.6 0.85", style="rounded,dashed"];
        7[label = "get_genome_gff3\ngenome_id: NCTC8325", color = "0.06 0.6 0.85", style="rounded,dashed"];
        8[label = "multiqc", color = "0.17 0.6 0.85", style="rounded"];
        9[label = "fastqc", color = "0.50 0.6 0.85", style="rounded,dashed"];
        10[label = "generate_rulegraph", color = "0.39 0.6 0.85", style="rounded,dashed"];
        1 -> 0
        8 -> 0
        10 -> 0
        2 -> 1
        7 -> 1
        3 -> 2
        4 -> 3
        5 -> 3
        6 -> 5
        9 -> 8
        4 -> 9
} 
```



# Anatomy of a Snakemake rule

## {auto-animate=true}

- rules are typically named and have input and/or output directives

``` {.python}
rule trim_fastq:
    output: temp("{sample}.trimmed.fastq")
    input: "{sample}.fastq"
    shell:
        """
        seqtk trimfq -b 5 -e 10 {input} > {output}
        """
```

## {auto-animate=true}

- logfiles help with debugging and leave a "paper trail"

``` {.python code-line-numbers="4,7"}
rule trim_fastq:
    output: temp("{sample}.trimmed.fastq")
    input: "{sample}.fastq"
    log: "logs/{sample}.trim_fastq.log"
    shell:
        """
        seqtk trimfq -b 5 -e 10 {input} > {output} 2> {log}
        """
```

## {auto-animate=true}

- params can be used to pass on settings

``` {.python code-line-numbers="5-7,10"}
rule trim_fastq:
    output: temp("{sample}.trimmed.fastq")
    input: "{sample}.fastq"
    log: "logs/{sample}.trim_fastq.log"
    params:
        leftTrim=5,
        rightTrim=10
    shell:
      """
      seqtk trimfq -b {params.leftTrim} -e {params.rightTrim} {input} > {output} 2> {log}
      """
```

## {auto-animate=true}

- the `threads` directive specify maximum number of threads for a rule
- you can also define `resources` such as disk/memory requirements and runtime 

``` {.python code-line-numbers="8-11,14"}
rule trim_fastq:
    output: temp("{sample}.trimmed.fastq")
    input: "{sample}.fastq"
    log: "logs/{sample}.trim_fastq.log"
    params:
        leftTrim=5,
        rightTrim=10
    threads: 8
    resources: 
        mem_mb=64,
        runtime=120
    shell:
      """
      seqtk trimfq -t [threads} -b {params.leftTrim} -e {params.rightTrim} {input} > {output} 2> {log}
      """
```

## {auto-animate=true}

- rules can be executed in separate software environments using either the `conda` or `container` directive

``` {.python code-line-numbers="12-13"}
rule trim_fastq:
    output: temp("{sample}.trimmed.fastq")
    input: "{sample}.fastq"
    log: "logs/{sample}.trim_fastq.log"
    params:
        leftTrim=5,
        rightTrim=10
    threads: 8
    resources: 
        mem_mb=64,
        runtime=120
    conda: "envs/seqtk.yaml"
    container: "docker://quay.io/biocontainers/seqtk"
    shell:
      """
      seqtk trimfq -t [threads} -b {params.leftTrim} -e {params.rightTrim} {input} > {output} 2> {log}
      """
```

`envs/seqtk.yaml`

``` {.yaml}
name: seqtk
channels:
  - bioconda
dependencies:
  - seqtk
```

## See more in the Snakemake documentation

[https://snakemake.readthedocs.io/en/stable/snakefiles/rules.html](https://snakemake.readthedocs.io/en/stable/snakefiles/rules.html)

# Snakemake commandline

::: {.fragment}

- Generate the output of the first rule in Snakefile

``` {.commandline code-line-numbers=false} 
$ snakemake -s Snakefile
```
:::

::: {.fragment}

- Run the workflow in dry mode and print shell commands

``` {.commandline code-line-numbers=false}
$ snakemake -n -p
```

:::

::: {.fragment}

- Execute the workflow with 8 cores

``` {.commandline code-line-numbers=false}
$ snakemake --cores 8
```

:::

::: {.fragment}

-  Specify a configuration file

``` {.commandline code-line-numbers=false}
$ snakemake --configfile config.yaml
```

:::

::: {.fragment}

- Run rules with specific conda environments

``` {.commandline code-line-numbers=false}
$ snakemake --use-conda
```

:::

::: {.fragment}

- Run rules with specific Singularity or Docker containers

``` {.commandline code-line-numbers=false}
$ snakemake --use-singularity
```

:::

# Questions?